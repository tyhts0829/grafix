# どこで: `src/grafix/export/gcode.py`。

# 何を: ペンアップ移動（非描画 travel）の総距離を小さくするための「パス並び替え最適化」を追加する実装改善計画。

# なぜ: 描画ジオメトリ（ペンダウンの軌跡）を変えずに、無駄な移動距離と描画時間を減らすため。

# G-code: ペンアップ移動距離最小化（パス最適化）実装計画（2026-01-10）

## 0. 前提（現在地）

- 対象: `src/grafix/export/gcode.py:export_gcode()`
- 現状の最適化:
  - `connect_distance` は「ペンアップを省略してペンダウンのまま次の始点へ移動」= **描画で繋ぐ**最適化。
  - 依頼内容の「ペンの描画ではない、ただの移動距離最小化」とは目的が異なる。
- 現状の travel は「入力順のまま」:
  - レイヤ → polyline → （紙クリップ後の）seg を入力順に処理し、各 seg 開始のたびにペンアップ移動する。
  - そのため、線が増えるほど「遠い場所へ行って戻る」ような非効率が起きやすい。

## 1. ゴール

- ペンダウン（描画）の軌跡を一切変えずに、ペンアップ移動（travel）の総距離を小さくする。
  - 並び替えと、各ストロークの「反転（逆向き描画）」のみ許可（どちらも線分集合は不変）。
- 出力が決定的（同じ入力 → 同じ G-code）。
- 依存追加なし（標準ライブラリ + 既存の `numpy` の範囲）。

## 2. 非ゴール（今回やらない）

- 真の最短（TSP の厳密解）。
- travel を直線以外（回避経路、加減速、衝突回避）にする。
- レイヤ間の意味（色/ペン差）を推測して自動で混ぜる。
- GUI/interactive 側の実行最適化（並列化/進捗 UI）。

## 3. 仕様（確定）

- 既定は travel 最適化を有効にする（`GCodeParams.optimize_travel=True`）。`False` の場合は入力順で出力する。

### 3.1 最適化単位

- 既存の紙クリップ後に得られる「描画可能な連続区間」= `seg` を 1 ストロークとして扱う。
  - 1 ストロークは `[(x0,y0), (x1,y1), ...]` の点列（canvas 座標系）。
  - ストローク間は必ず「ペンアップ移動」で接続する（描画で繋がない）。

### 3.2 最適化範囲

- **レイヤ内のみ**並び替える（既存の「レイヤ跨ぎの事故線回避」と同じ思想）。

### 3.3 反転（逆向き描画）

- 既定: 許可する（移動距離が確実に減るケースが多い）。
- 反転が同距離で並ぶ場合は「元の向き」を優先して決定性を担保する。

### 3.4 距離評価の座標系

- canvas 座標系で評価する（Y 反転・origin は等長変換なので距離は不変、実装が単純）。

### 3.5 アルゴリズム（最小）

- Phase 1（必須）: 貪欲法（Nearest Neighbor）
  - 開始ストロークは「入力順の先頭固定」（レイヤ内）。
  - 以降は現在位置（直前ストロークの終点）から次ストロークの start/end までの距離を比較し、最短になるものを選ぶ。
  - 反転を許可する場合は「近い端点を入口にする向き」を同時に選ぶ。
  - タイブレーク: （距離が同じなら）`(layer_idx, poly_idx, seg_idx)` の昇順で安定選択。
- Phase 2（任意）: 2-opt 改善
  - ストローク数が多いときの改善余地が大きいが、実装/計算量が増えるため後回し。

## 4. `connect_distance` の扱い（決定）

`connect_distance` は「描画で繋ぐ」ので、今回の最適化と混ぜると意図しない線が出やすい。

決定:

- `connect_distance` を削除する（最も明確。互換シムは作らない）。

## 5. 実装方針（最小）

### 5.1 内部データ構造

- `Stroke`（内部 dataclass）を導入:
  - `layer_idx, poly_idx, seg_idx`
  - `points_canvas: list[tuple[float, float]]`
  - `start/end`（距離評価用。必要なら machine/quantized も保持）

### 5.2 パイプライン再構成

- 既存の「走査しながら即 G-code 出力」を二段化:
  1. 収集: 各 layer の全ストロークを生成（紙クリップ後の seg 群）。
  2. 最適化: layer ごとに stroke order を決定（並び + 反転）。
  3. 出力: 決定した順で「travel → draw」を出力。

### 5.3 決定性（同入力 → 同出力）

- 距離比較は平方距離で行い、タイブレーク規則を明文化して実装する。
- 浮動小数の微小差で順序が揺れないよう、距離評価点は「丸め後座標」または「int 化座標」を使う（canvas 座標系のまま安定化する）。

## 6. テスト方針

- 旅行距離の比較テストを追加:
  - 同じ入力に対して `optimize_travel=False` と `True` を出力し、pen-up 区間の移動距離が減ることを検証する。
  - 距離の算出は G-code をパースして `Z` 状態を追跡し、`Z up` 中の `X/Y` 移動だけを積算する。
- 決定性テスト:
  - `optimize_travel=True` でも 2 回出力が一致する。
- 形状不変の簡易検証:
  - 「ペンダウン中に出る `G1 X.. Y..` の点列集合」が同一（順序は変わってよい）であることを確認する（過剰に厳密にはしない）。

## 7. ユーザー確認が必要な決定事項

- [x] 1. 最適化の既定: `optimize_travel` は既定で有効にする？（出力が大きく変わる）；はい
- [x] 2. 最適化範囲: レイヤ内のみで良い？ それとも全レイヤ一括？；レイヤ内のみで
- [x] 3. 反転: 既定で許可して良い？（線は同じだが描画方向は変わる）；はい
- [x] 4. 距離評価: canvas 座標系で十分？ それとも machine 丸め後で評価したい？；canvas 座標系でいい
- [x] 5. `connect_distance` の扱い: 4 の A/B/C のどれが好み？；A
- [x] 6. 初期位置: 先頭ストロークは「入力順の先頭固定」で良い？ それとも `G28` 後の `(0,0)` を起点に最短のストロークを選びたい？；先頭固定で

## 8. 実装チェックリスト

- [ ] 1. 公開 API / パラメータ整理
  - [ ] `GCodeParams.connect_distance` を削除（呼び出し側/テスト/ドキュメントも追従）
  - [ ] `GCodeParams.optimize_travel` を追加（既定 True）
  - [ ] 反転は既定で許可（必要なら `allow_reverse` を追加して既定 True）
  - [ ] 先頭ストロークは「入力順の先頭固定」、以降を最適化する（レイヤ内）
- [ ] 2. ストローク収集処理を実装（紙クリップ後の seg → stroke 化）
- [ ] 3. 最適化（貪欲法）を実装（並び + 反転）
  - [ ] タイブレーク規則の実装
  - [ ] 距離評価は canvas 座標系（3.4）
- [ ] 4. G-code 出力を最適化順に変更
  - [ ] コメント出力（`stroke layer/poly/seg ...`）の方針を決める（デバッグ用）
- [ ] 5. 保存ファイル名に canvas_size を含める（追加要求）
  - [ ] どこで付与するかを確定（`output_path_for_draw` / gcode 専用ヘルパ / `export_gcode` 側）
  - [ ] 付与フォーマットを確定（例: `..._800x800.gcode`。小数が入る場合の表記ルールも）
  - [ ] interactive の既定出力パス生成が canvas_size 付きになる（`Saved G-code: ...` の表示も一致）
- [ ] 6. テスト追加/更新（`tests/export/test_gcode.py` / `tests/export/test_gcode_travel_opt.py` など）
  - [ ] travel 距離が減ること
  - [ ] 決定性
- [ ] 7. 静的チェック
  - [ ] `ruff check src/grafix/export/gcode.py tests/export/...`
  - [ ] `mypy src/grafix/export/gcode.py`
  - [ ] `PYTHONPATH=src pytest -q tests/export/...`

## 9. 追加で確認したいこと（実装中に追記）

- [ ] stroke 数が多いケースの実測（N が大きいと O(N^2) が重くなる）。必要なら軽いヒューリスティクスを検討する。
- [ ] 「最適化の前後で travel 距離をコメントとして埋める」など、デバッグ容易性を上げるか。
- [ ] 既存テスト（`tests/export/test_gcode.py`）に仕様と食い違う項目がないか（必要なら整理してから最適化テストを追加する）。

## 10. 保存ファイル名に canvas_size を含める（追加要求）

### 10.1 目的

- 同じ draw/run_id でも `canvas_size` が違う出力は別物なので、上書きや取り違えを避ける。

### 10.2 方針（最小）

- export 自体（`export_gcode(..., path=...)`）は **渡された path に保存するだけ**に保つ。
- 既定パス生成側（`grafix.core.output_paths.output_path_for_draw` と、その呼び出し側）で canvas_size をファイル名へ埋め込む。

### 10.3 ファイル名フォーマット案

- `{stem}_{w}x{h}{run_id_suffix}.{ext}`
  - 例: `sketch_800x800.gcode`, `sketch_210x297_v2.svg`
  - `w/h` は `canvas_size` から作る（小数が入る場合は末尾 0 を落として短くする）。

### 10.4 影響範囲（想定）

- interactive の既定出力:
  - `SVG` / `G-code`（必要なら `PNG` も）を canvas_size 付きにする。
- 既にユーザーが明示指定している path（例: `Export(..., path="out.gcode")`）は変更しない。
