了解。ここでは「Grafix を“実行・レンダリング・成果物取得”するための Grafix専用MCPサーバを実装する」前提で、MCPの実装計画を切ります。オーケストレーター（後で作るskills）が、このMCPを呼んで 4並列×（アイデア/実装/批評）ループを回せる、という設計ゴールに合わせます。

1. 何をMCP化するか（スコープの切り方）

あなたのループで“機械にやらせたい”部分は、ほぼ「実装役が Grafix を走らせて画像（やgcode）を吐く」工程です。逆に、コンセプトや批評はLLM内部で完結しやすい（＝MCP化の旨みが薄い）ので、MCPサーバは Grafixの実行系に特化させるのが素直です。

MCP自体は「LLMが外部機能を安全に呼ぶための標準I/F」で、stdio/HTTPなどのトランスポート上で JSON-RPC でやり取りします。ローカルで回すなら stdio が最も簡単で、クライアントがサブプロセスとしてサーバを起動します。 ￼
実装は公式の MCP Python SDK（PyPIの mcp）を使うのが早いです。 ￼

2. サーバの“契約”（ツールI/F）を先に固定する

マルチエージェントで回す場合、I/Fが曖昧だと並列化が破綻します。まず「最低限これだけあれば回る」MVPツールを固定します。おすすめは次の5つです（これで“実装→画像→批評→改善”が閉じます）。
• grafix.render：指定したスケッチ（Python）をヘッドレスで実行してPNG/SVG等を出す
• grafix.export_gcode：同じ入力から gcode を生成する（対応している場合）
• grafix.get_artifact：出力ファイルを取得（パス返却 or base64返却のどちらかを採用）
• grafix.list_artifacts：あるworkspace/iterationの成果物一覧
• grafix.metrics：批評の補助用に、線分数・総線長・インク被覆率の粗い推定・バウンディング等のメトリクスを返す（画像を見ない“高速ふるい”に効く）

ここで重要なのは、ツールの引数に workspace_id / run_id / variant_id を入れて、4並列を衝突なく回せるようにすることです（後述）。

3. 実装アーキテクチャ（stdio MCPサーバ + workspace分離）

3.1 プロセス構成

Grafix MCPサーバは stdio MCPサーバとして動かし、オーケストレーター（Agents SDKやCodex等のMCPクライアント）がサブプロセス起動します。stdioはこの用途に最適化されています。 ￼

3.2 workspace設計（4並列の要）

4並列×反復で品質を上げるなら、「成果物・ログ・コード差分」が混ざらない構造が必要です。サーバは次の規約でファイルを置くのが無難です。

<root>/workspaces/<workspace_id>/runs/<run_id>/variants/<variant_id>/

そして grafix.render は必ずこの配下にしか書き込めない（パス検証で脱出禁止）ようにします。これで安全性と再現性が上がります。

3.3 実行方法（Grafixをどう走らせるか）

Grafixの実行は2択です。

(1) Python APIとしてimportして呼ぶ：最速だが、スケッチのロードや副作用（GUI等）を殺す設計が必要。
(2) サブプロセスで python <sketch_runner>.py ... を起動：遅いが隔離が強く、落ちてもサーバが死ににくい。

マルチエージェント＋並列で安定させたいなら、最初は(2)が堅いです。後で安定したら(1)へ寄せる。

4. ツール仕様の具体案（MVP）

ここは“skillsが呼びやすい形”が正義です。例えば grafix.render は次のような入力を取ると運用しやすいです。
• 入力：workspace_id, run_id, variant_id, sketch_path, params（JSON）, seed, canvas_size, render_scale, time（t固定なら）, output_formats（png/svg）
• 出力：artifacts（生成されたファイルの相対/絶対パス）, metrics（簡易）, stdout/stderr（要約）

params をJSONで受けるのが効きます。実装役が「ここをこう変える」を差分として出し、サーバはそれをそのまま実行に反映できるからです。

grafix.get_artifact は2方式あります。
• A: パスだけ返す → クライアント側でファイルを読んでLLMに画像として渡す（実装が最も簡単）
• B: base64 + mime を返す → クライアントの実装が簡単になる（ただし巨大化しやすい）

最初はAで良いです。必要になったらBを追加。

5. セキュリティ・暴走対策（最低限ここはやる）

MCPサーバは「外部からコマンドが飛んでくる口」なので、やるべき制限が明確です。
• 書き込み先を workspace配下に固定（パストラバーサル禁止）
• 任意コマンド実行は提供しない（Grafix実行に必要な限定コマンドだけ）
• 実行時間のタイムアウト、メモリ上限、プロセスkill
• 乱数seedとバージョン（Grafix/git rev、依存関係）を成果物メタデータに記録（再現性）

この「再現性メタデータ」は、批評ループの品質を上げます。良かった作品の“生成条件”を確実に掘り出せるからです。

6. 実装ステップ（フェーズ分割）

時間見積もりではなく、実装を失敗しにくい順番で切ります。

フェーズ1（MVP）：grafix.render と grafix.list_artifacts だけ作る。stdioで起動できて、1回レンダできれば合格。
フェーズ2（ループ成立）：grafix.metrics と grafix.get_artifact を足す。批評役が「画像＋定量」を見て改善指示できる状態にする。
フェーズ3（並列最適化）：workspace/run/variant の運用を固め、4並列で衝突しないことをテストする。
フェーズ4（製品化）：export_gcode、キャッシュ（同条件なら再レンダ省略）、ログ整備。

7. どうやって呼ぶか（Codex / Agents SDK どちらでも）

Codex側からMCPサーバを使うなら、Codexは config.toml にMCPサーバ設定を持ち、CLI/IDEで共用します。 ￼
Agents SDK側からなら、stdio MCPサーバとして起動してツールとして渡すのが基本形です。 ￼

どちらでオーケストレーターを作っても、ここで設計した「ツール契約」が同じなら、後で差し替えが効きます。

⸻

ここまでが「Grafix MCPサーバ」の実装計画です。次のステップ（あなたが言う“オーケストレーター向けskills”）に繋げるために、こちらから先に確認しておくべき“前提”を一つだけ挙げます。あなたのGrafixは、スケッチをGUIなしで一発レンダリングしてPNGを吐くためのエントリポイント（CLIまたは関数）が既にありますか？
もし既にあるなら、それをサーバが叩く設計で最短になります。もし無いなら、まず「headless runner（sketchを読み込んで静的画像を生成する小さな実行スクリプト）」をGrafix側に追加するのがフェーズ1の中心作業になります。
