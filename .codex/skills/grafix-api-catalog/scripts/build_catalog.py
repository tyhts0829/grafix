from __future__ import annotations

import importlib
import inspect
import pkgutil
import sys
from pathlib import Path
from typing import Any, Callable


def _repo_root() -> Path:
    # skills/grafix-api-catalog/scripts/build_catalog.py -> repo root
    return Path(__file__).resolve().parents[3]


def _ensure_src_on_path() -> None:
    src_dir = _repo_root() / "src"
    sys.path.insert(0, str(src_dir))


def _import_builtin_ops() -> None:
    importlib.import_module("grafix.api.primitives")
    importlib.import_module("grafix.api.effects")


def _iter_modules(package_name: str):
    pkg = importlib.import_module(package_name)
    yield pkg
    for info in pkgutil.iter_modules(pkg.__path__, pkg.__name__ + "."):
        yield importlib.import_module(info.name)


def _find_impl_functions(package_name: str, names: set[str]) -> dict[str, Callable[..., Any]]:
    remaining = set(names)
    out: dict[str, Callable[..., Any]] = {}
    for module in _iter_modules(package_name):
        keys = set(module.__dict__.keys()) & remaining
        for name in sorted(keys):
            obj = module.__dict__[name]
            if callable(obj):
                out[name] = obj
                remaining.remove(name)
        if not remaining:
            break
    return out


def _first_doc_line(obj: object) -> str:
    doc = inspect.getdoc(obj)
    if not doc:
        return ""
    for line in doc.splitlines():
        s = line.strip()
        if s:
            return s
    return ""


def _short_repr(v: object, *, max_len: int = 80) -> str:
    s = repr(v)
    if len(s) <= int(max_len):
        return s
    return s[: max(0, int(max_len) - 1)] + "…"


def _rel_source_path(func: Callable[..., Any], *, repo_root: Path) -> str:
    try:
        p = Path(inspect.getsourcefile(func) or "").resolve()
    except Exception:
        return ""
    if not p.exists():
        return ""
    try:
        return str(p.relative_to(repo_root))
    except Exception:
        return str(p)


def _meta_table(
    meta: dict[str, Any],
    defaults: dict[str, Any],
    *,
    param_order: tuple[str, ...] | None,
) -> list[str]:
    names = list(param_order or ())
    if not names:
        names = sorted(meta.keys())

    if "bypass" in names:
        names = [n for n in names if n != "bypass"] + ["bypass"]

    lines = [
        "| param | kind | default | ui | choices |",
        "| --- | --- | --- | --- | --- |",
    ]
    for name in names:
        if name not in meta:
            continue
        m = meta[name]
        kind = getattr(m, "kind", "")
        ui_min = getattr(m, "ui_min", None)
        ui_max = getattr(m, "ui_max", None)
        ui = ""
        if ui_min is not None or ui_max is not None:
            ui = f"{_short_repr(ui_min)}..{_short_repr(ui_max)}"
        choices = getattr(m, "choices", None)
        choices_s = "" if choices is None else ", ".join(str(c) for c in choices)
        default_s = "" if name not in defaults else _short_repr(defaults[name])
        lines.append(f"| {name} | {kind} | {default_s} | {ui} | {choices_s} |")
    return lines


def _build_markdown() -> str:
    _ensure_src_on_path()
    _import_builtin_ops()

    from grafix.core.effect_registry import effect_registry
    from grafix.core.primitive_registry import primitive_registry

    repo_root = _repo_root()

    effect_names = sorted(name for name, _ in effect_registry.items() if not name.startswith("_"))
    primitive_names = sorted(
        name for name, _ in primitive_registry.items() if not name.startswith("_")
    )

    effect_impl = _find_impl_functions("grafix.core.effects", set(effect_names))
    primitive_impl = _find_impl_functions("grafix.core.primitives", set(primitive_names))

    lines: list[str] = []
    lines.append("# Grafix API Catalog（generated）")
    lines.append("")
    lines.append("- generated by: `skills/grafix-api-catalog/scripts/build_catalog.py`")
    lines.append("- do not edit this file manually")
    lines.append("")

    lines.append("## Effects")
    lines.append("")
    for name in effect_names:
        func = effect_impl.get(name)
        summary = "" if func is None else _first_doc_line(func)
        src = "" if func is None else _rel_source_path(func, repo_root=repo_root)
        n_inputs = int(effect_registry.get_n_inputs(name))
        meta = effect_registry.get_meta(name)
        defaults = effect_registry.get_defaults(name)
        order = effect_registry.get_param_order(name) or None

        lines.append(f"### {name}")
        lines.append("")
        if summary:
            lines.append(summary)
            lines.append("")
        if src:
            lines.append(f"- 実装: `{src}`")
        lines.append(f"- 入力数: {n_inputs}")
        if n_inputs == 1:
            lines.append(f"- 呼び出し: `E.{name}(...)(g)`")
        else:
            lines.append(f"- 呼び出し: `E.{name}(...)(g1, g2, ...)`（multi-input）")
        lines.append("")
        lines.extend(_meta_table(meta, defaults, param_order=order))
        lines.append("")

    lines.append("## Primitives")
    lines.append("")
    for name in primitive_names:
        func = primitive_impl.get(name)
        summary = "" if func is None else _first_doc_line(func)
        src = "" if func is None else _rel_source_path(func, repo_root=repo_root)
        meta = primitive_registry.get_meta(name)
        defaults = primitive_registry.get_defaults(name)
        order = primitive_registry.get_param_order(name) or None

        lines.append(f"### {name}")
        lines.append("")
        if summary:
            lines.append(summary)
            lines.append("")
        if src:
            lines.append(f"- 実装: `{src}`")
        lines.append(f"- 呼び出し: `G.{name}(...)`")
        lines.append("")
        lines.extend(_meta_table(meta, defaults, param_order=order))
        lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def main() -> int:
    repo_root = _repo_root()
    out_path = repo_root / "skills/grafix-api-catalog/references/api.md"
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(_build_markdown(), encoding="utf-8")
    print(f"Wrote: {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

