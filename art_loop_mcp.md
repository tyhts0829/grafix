部分的にMCP化するのは、設計の切り方さえ間違えなければ「エージェントが作品を作りやすくなる」方向に効きます。ただし、MCP化が効くのは“創作そのもの”よりも、“創作を回すための手続き”です。逆に、ideaman/artist/criticの中核判断までツールに寄せると、むしろ作品づくりの柔軟性が落ちたり、ループが形骸化します。
あなたのGrafixループの仕様を見る限り、すでに「LLMが守るべき運用制約」がかなり多い。たとえば、出力は必ず sketch/agent_loop/runs/<run_id>/ 配下、/tmp 禁止、レンダリングは固定コマンド、primitive/effectはCLIのlistを正として参照、各variantは独立実装でshared禁止、custom primitive/effectの定義と実使用必須、などです。こういう“忘れると事故るが、創造性には直結しない決まり”は、まさにツール（=MCPサーバ）に埋め込んだほうがエージェントにとって楽になります。LLMは忘れますが、ツールは忘れません。
SKILL

SKILL
MCP化の価値は、コンテキスト節約というより「状態管理・検証・実行の確実化」にあります。結果として、失敗→再実行→ログ貼り付け→指示の再説明、みたいなトークン浪費が減る、という順序で効きます。とくにGrafixは「実行してみないと分からない」要素（依存、レンダリング、レジストリ一致、画像生成結果、ログ）が大きいので、LLMが手でCLIを叩いてログを長文で抱えるより、ツールが“短い構造化サマリだけ返す”ほうが反復が速くなります。
SKILL
一方で、MCP化してはいけない領域も明確です。あなたの仕様では ideaman/artist/critic は「LLMが担うrole」であり、固定JSON生成スクリプトや一時Pythonで代替するのを明確に禁じています。ここをツールに置き換えると、ループが“定型生成→定型批評”に退化して、作品の探索が止まります。したがってMCP化のターゲットは、あくまで周辺作業（実行・検証・集約）に限定するのが筋です。
SKILL

SKILL

SKILL

SKILL
具体的に「MCP化すると効く機能」を、あなたの制約に沿って言うと、まず primitive/effect のレジストリ取得と検証はツール化の相性が非常にいいです。仕様上、CLI結果が正でフォールバックも決まっているので、MCPツールを list_primitives() / list_effects() として提供し、戻り値は配列だけ（＋取得元がCLIかfallbackか）にすれば、毎回の“参照手順の説明”も“誤キーで事故る”も減ります。
SKILL
次にレンダリング実行です。仕様では /opt/anaconda3/envs/gl5/bin/python -m grafix export で統一、stdout/stderrもrun配下保存、/tmp禁止など、実行周りのルールが多い。ここを export_variant(variant_dir) の1コールに閉じ込めると、LLMは「何を作るか」に集中し、実行手順のミスが激減します。返す情報も、成功/失敗、出力PNGのパス、実行時間、エラーの先頭数行程度で足ります（全文ログはファイルに残して必要なときだけ追加取得）。
SKILL

SKILL
さらに contact sheet と最終8Kサマリ生成は、完全に機械的で、しかも「必ず作れ」と仕様で固定されています。ここを make*contact_sheet(iter_dir) と make_final_contact_sheet(run_dir) にすると、LLM側の実装ぶれがなくなり、毎回同じ成果物が残って比較が楽になります。
SKILL
最後に地味ですが効くのが“監査・検証”です。たとえば scan_output_boundary(run_dir) で run配下以外に生成物がないかチェックする、validate_variant(sketch.py) で @primitive/@effect が定義されていて実際に使われているか最低限の静的検査をする、check_uniqueness(run_dir) で primitive_key + effect_chain_key の再利用や custom*\*\_name 重複を検出する。これらは作品の良し悪しには直接関与しない一方、ループの健全性と探索多様性を守る上では重要で、LLMが都度手でやるのに向きません。
SKILL

SKILL

SKILL
逆に、MCP化を控えたほうがいいのは「アイデア生成そのもの」「批評の判断」「どの表現が“勝ち”かの価値判断」です。ここをツールにすると、ツールは結局“固定ルール”しか持てないので、探索の質が落ちますし、あなたの仕様が禁じている“固定テンプレ化”に引っ張られやすい。MCPは、創作の判断を代替するより、創作判断が回り続けるためのインフラとして使うほうが合っています。
SKILL

SKILL
あなたの最初の問題意識（コンテキストの無駄遣い）に戻すと、MCP化で本当に効くのは「ログや中間情報を会話に貼らないで済む」形に寄せられる点です。ツールの返却を短い構造化JSONにして、詳細は“必要なときだけ read_log(path, tail=2000) で取る”ようにすれば、トークンは確実に減ります。反対に、ツールが毎回巨大なログや画像のメタデータを返す設計にすると、MCP化してもコンテキストは減りません。鍵は“返却を短く、再問い合わせ可能にする”です。
したがって提案はシンプルで、「grafixの一部MCP化はやる価値が高いが、対象は実行・検証・集約に限る」です。最小構成としては、(1) レジストリ取得、(2) export実行、(3) contact sheet生成、(4) 境界監査、の4つだけMCP化して効果を見るのが合理的です。この4つはあなたのSKILL仕様に直結していて、失敗コストを下げ、反復速度を上げ、結果として作品の探索回数を増やせます
