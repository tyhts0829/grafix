目的と前提

ここで作る「skill」は、Grafix（外部ライブラリ）を使ったジェネラティブ画像生成を対象に、**アイデア出し → 実装 → 画像出力 → 批評 → 改善実装 → 画像出力 → 批評…**という反復を、合計 N 回まわして最終成果を得るためのオーケストレーション一式です。Grafix の具体 API、CLI、レンダリング設定、依存関係、出力形式などは不確実なので、Grafix への依存はアダプタ層に隔離し、実装時に動作確認して確定させる方針にします。

また要件として、各反復における「実装（または改善実装）→画像出力」は M 並列で別々のアーティスト（実装屋）が行い、M 個のバリエーションを生成します。批評家は 全候補を確認した上で、美的に最も優れている 1 つを選び、それだけを次ループに持ち越します。

⸻

役割分担と責務境界

この設計は「誰が何を決め、何を返すか」を厳密に固定しないと、ループが崩れます。各役割の入出力を JSON（または厳格な構造）で縛る前提で、責務を切ります。

オーケストレーター（統括・状態管理）

オーケストレーターは、N 反復の進行、並列実行、失敗時の扱い、成果物の保存、次反復への引き継ぎを担当します。具体的には、(1) アイデアマンへ要求を投げる、(2) M 人のアーティストへ同一ブリーフと各自の探索方針を渡す、(3) 返ってきた画像とメタデータを束ねて批評家に渡す、(4) 批評家の選定結果から「勝ち残り 1 つ」を次反復のベースにする、を毎回実行します。

オーケストレーター自身は Grafix の詳細は知らない前提なので、画像生成は「Grafix アダプタ（後述）」経由で呼ぶだけにします。

アイデアマン（アイデア出し）

アイデアマンは「生成物の方向性」を定義します。ここで重要なのは、単なるテーマ案ではなく、実装に落とせるブリーフ（例えば「形状語彙」「構図制約」「反復の変数軸」「避けたい破綻」など）を返すことです。

初回（反復 1）では必ずアイデアマンを呼びます。2 回目以降は、方針として二択にできます。固定で呼ぶ（毎回刷新）か、基本は批評家の改善指示に従い、停滞が検出されたときだけ呼ぶ（探索の再注入）かです。計画としては、後者が安定します（改善ループが「別作品の再発明」に逸れにくい）。

アーティスト（実装屋）

アーティストは、与えられたブリーフと「前回の勝ち残りコード（またはスケッチ）」と「批評家の改善指示」を入力に、実装（または改善実装）を行い、Grafix で画像を書き出して返します。M 並列では、同じ要求を投げるのではなく、各アーティストに“探索ポリシー”を変えて渡すことで、バリエーションが意味を持ちます（例：ミニマル寄り、幾何学寄り、テクスチャ寄り、構図優先、色優先、アルゴリズム優先など）。

「実装 → 画像出力」までがアーティストの責務であり、オーケストレーターはアーティストから「画像ファイルパス・実行ログ・主要パラメータ・seed・要約」を受け取るだけにします。

批評家（審査・選抜・改善指示）

批評家は、M 個の候補を同一基準で批評して、最も美的に優れている 1 つを選びます。その際、単に褒める/貶すではなく、次反復へ渡すための「改善指示」を構造化して返す必要があります。改善指示は、勝ち残り作品の「伸ばすべき点」と「直すべき点」を明確にし、アーティストが次回の実装で実行可能な形（例：構図の変更、パラメータのレンジ調整、密度の制御、線の太さの方針、余白の扱い、反復のノイズ構造など）に落として返します。

⸻

反復ループの仕様（N 回）

反復 i（1..N）で行う処理を、状態遷移として固定します。ここでは「初回の実装」と「改善実装」は同じフェーズで扱い、入力（ベース）が違うだけ、と定義しておくのが実装が楽です。

反復 1 ではベースが空なので、アイデアマンのブリーフをベースに M 本作ります。反復 2..N では、前回勝ち残り 1 本をベースにして M 本の改善案を作ります。

⸻

データモデル（最低限これだけは持つ）

運用で破綻しやすいのは「何が次に渡るかが曖昧」なケースなので、状態を固定します。以下は JSON を想定した概念モデルで、実際は Pydantic 等で型を持たせると安全です。

CreativeBrief（アイデアマン出力）には、少なくとも作品意図と実装上の制約を入れます。Artifact（アーティスト出力）は、コードと画像と再現情報を一体化します。Critique（批評家出力）は、選抜結果と改善指示を含みます。

{
"run_id": "YYYYMMDD-HHMMSS-xxxx",
"N": 8,
"M": 6,
"iteration": 3,
"creative_brief": {
"title": "...",
"intent": "...",
"constraints": {
"canvas": "unknown (confirm in grafix)",
"time_budget_sec": 30,
"avoid": ["..."]
},
"variation_axes": ["...", "..."],
"aesthetic_targets": "..."
},
"baseline_artifact": {
"code_ref": "path/to/baseline.py",
"seed": 12345,
"notes": "..."
},
"critic_feedback_prev": {
"keep": "...",
"change": "...",
"next_actions": ["..."]
}
}

アーティストの返却は、成功/失敗を含めて統一します。

{
"artist_id": "artist-04",
"iteration": 3,
"variant_id": "v4",
"status": "success",
"code_ref": "runs/.../iter_03/v4/sketch.py",
"image_ref": "runs/.../iter_03/v4/out.png",
"seed": 12402,
"params": {"...": "..."},
"stdout_ref": "runs/.../iter_03/v4/stdout.txt",
"stderr_ref": "runs/.../iter_03/v4/stderr.txt",
"artist_summary": "何をどう変えたか"
}

批評家の返却は、最終的に「次へ回す 1 つ」と「改善指示」を必ず含めます。

{
"iteration": 3,
"ranking": [
{"variant_id": "v4", "score": 8.7, "reason": "..."},
{"variant_id": "v1", "score": 7.9, "reason": "..."}
],
"winner": {
"variant_id": "v4",
"why_best": "...",
"what_to_preserve": "...",
"what_to_fix_next": "...",
"next_iteration_directives": [
{"priority": 1, "directive": "...", "rationale": "..."},
{"priority": 2, "directive": "...", "rationale": "..."}
]
}
}

⸻

Grafix 依存を隠すアダプタ設計

Grafix の詳細が不明な前提なので、「アーティストが描画コードを生成して、画像を吐く」という操作だけを抽象化します。ここは最初に“動く最小”を作って API を確認し、最終的にアダプタに閉じ込めます。

設計上は GrafixAdapter（名前は任意）を置き、以下の責務に限定します。

(1) 指定されたスケッチ/コードを実行して画像を生成する（実行方法は Grafix の実装で確認して決める）。
(2) 画像が生成されたことを検証する（ファイル存在、サイズ、破損チェック程度）。
(3) 実行ログとメタデータ（使用 seed や主要パラメータ）を返す。

このアダプタは、将来 Grafix の CLI 方式でも、Python API 方式でも差し替え可能にするため、呼び出し側（アーティスト）には「render(code_ref, output_path, seed, params)」程度の抽象 I/F だけ見せます。具体コマンドや関数名は実装確認で確定します。

⸻

M 並列の実行方式

並列化は「エージェントが別々に走る」ことが本質なので、単一プロセス内で乱数だけ変えるのではなく、少なくとも論理的に分離された実行単位を作ります。実装方式は次のいずれでも成立します。

一つは、オーケストレーターが M 個のサブプロセス（またはコンテナ）を起動し、それぞれに「artist prompt + baseline + feedback」を渡して実行させる方式です。もう一つは、エージェント実行基盤があるなら、基盤の並列機構（ワーカー）に投げて結果を集約する方式です。いずれにしても重要なのは、各バリアントが同じディレクトリや同じ一時ファイルを触らないよう、runs/<run_id>/iter_XX/vY/ に完全分離した作業領域を割り当てることです。

また、並列実行は失敗が混じる前提で設計します。例えば M=8 のうち 2 件がレンダリング失敗しても、残り 6 件で批評→選抜が進むようにします（ただし全滅は例外処理で、同一反復をリトライするか、アイデアを簡略化して再実行する）。

⸻

アーティストを「異なるエージェント」にする具体化

「異なるエージェント」を、単に別インスタンスという意味に留めると、出力が似通いがちです。実装計画としては、各アーティストに固定の“作家性プロファイル”を持たせ、毎回同じプロファイルで改善を続ける方が探索空間が安定します。

プロファイルは、例えば「優先する美学（余白、リズム、対称性、ノイズ、タイポグラフィ的構成など）」と「変更方針（色からいじる、形からいじる、アルゴリズムを変える、パラメータレンジを詰める等）」を文章としてシステムプロンプトに固定し、反復ごとに変えるのはブリーフと批評家の指示だけにします。これで M 本の候補が役割分担的に散らばります。

さらに、各アーティストには「前回勝ち残りを尊重する度合い」を変えて割り当てると、改善と探索が両立します。例えば、M のうち 70% は改善（exploit）として勝ち残りをベースに微調整し、30% は探索（explore）として勝ち残りから意図的に離れた案を出す、といったルールをオーケストレーターが持つ設計です。これは停滞回避に効きます。

⸻

批評家の入力設計（M 候補を「全部見る」を担保）

批評家に M 枚の画像を渡すとき、LLM のマルチモーダル入力制約（枚数上限、サイズ上限、トークン上限）がボトルネックになりやすいので、計画段階で“必ず全部見せる”仕組みを入れておきます。

現実的には、オーケストレーターが M 枚から「コンタクトシート（グリッド合成画像）」を生成し、批評家には (1) グリッド全体、(2) 上位候補の原寸（必要なら）を渡す設計が堅いです。これなら「全体比較」と「細部確認」の両方ができます。コンタクトシート生成自体は Grafix 依存ではなく、一般的な画像ライブラリで実装できます。

批評家の評価は主観でよいですが、毎回ぶれないように、評価観点を固定して文章化します。例えば「構図の安定性、視線誘導、密度と余白、色の一貫性、形状語彙の統一、偶然性の制御、破綻（潰れ・バンディング・ノイズの汚さ）回避」といった軸を、批評家プロンプトの中で“順番も含めて”固定します。こうすると iteration 間で改善方向が一貫しやすいです。

⸻

反復ごとの「引き継ぎ情報」を最小化する

ループ運用では、コンテキスト肥大化が一番の敵です。毎回全履歴を渡すと、批評家が一貫性を失うか、アーティストが曖昧な指示で迷走します。引き継ぐのは基本的に次の 3 点だけに絞ります。

第一に、勝ち残りの code_ref と image_ref。第二に、批評家が抽出した「維持すべき要素」と「次に直すべき要素」。第三に、アイデアマンのブリーフ（ただし必要最小限の要約版）です。過去の敗者の詳細は原則渡さず、必要なら批評家が一行で「避けるべき失敗例」を残す程度にします。

⸻

失敗処理と品質ゲート

並列実行では失敗が混じるので、オーケストレーター側で最低限の品質ゲートを設けます。ここは美的評価ではなく「評価対象として成立しているか」を機械的に弾く層です。

例えば、画像ファイルが存在しない、ファイルサイズが極端に小さい、読み込み不能、レンダリングがタイムアウトした、といったケースは status=failed として批評家には渡しません（渡しても時間の無駄）。一方で「意図はわかるがノイズが汚い」といった美的欠点は批評家の仕事なので、機械ゲートでは落としません。

また、失敗時に 1 回だけ自動リトライを入れるのは有効です。具体的には、アーティストに「エラー要約（stderr）だけ」を返して、最小修正で再レンダリングさせます。ただし無限再試行は全体が止まるので、各バリアントは最大 2 試行まで、といった上限を計画に明記しておきます。

⸻

実装構成（skill のモジュール設計）

実装計画としては、skill を「オーケストレーター本体」と「エージェント定義」と「Grafix アダプタ」と「成果物管理」に分割します。概念的なディレクトリ構成は以下のようになります（名前は任意）。

skills/grafix_loop/
orchestrator.py
agents/
ideaman.py
artist.py
critic.py
adapters/
grafix_adapter.py # Grafix の実装確認後に確定
schemas.py # CreativeBrief / Artifact / Critique の型
io/
workspace.py # runs/ 以下の保存規約
image_grid.py # コンタクトシート合成
prompts/
ideaman_system.txt
artist_system_base.txt
artist_profiles/
artist_01.txt
...
critic_system.txt

ここで agents/\*.py は「LLM への要求テンプレート」と「返却 JSON の検証・整形」を責務にし、実際のレンダリング実行は GrafixAdapter に寄せます。アーティストが「実装→画像出力」まで担う要件があるので、artist.py の中でアダプタを呼ぶ設計にします（オーケストレーターが描画する設計だと、役割分担が要件からズレます）。

⸻

反復の擬似コード（動作の骨格）

実装の骨格は次の形になります。Grafix の呼び出し箇所はアダプタに隠蔽され、ここでは抽象的に記述します。

def run_loop(N: int, M: int, config):
state = init_run_state(N, M, config)

    # 反復1のブリーフ生成
    state.creative_brief = ideaman.generate_brief(state)

    baseline = None
    critic_feedback = None

    for i in range(1, N + 1):
        iter_ctx = make_iteration_context(state, i, baseline, critic_feedback)

        # M並列：各アーティストが実装→画像出力
        results = parallel_map(
            lambda artist: artist.implement_and_render(iter_ctx),
            artists[0:M]
        )

        valid = [r for r in results if r.status == "success" and validate_image(r.image_ref)]
        if len(valid) == 0:
            # 全滅時の方針：簡略化して同iterationを再実行 or ブリーフ再生成など
            iter_ctx = recover_iteration(iter_ctx)
            continue

        # 批評家が全部見て1つ選ぶ
        grid = make_contact_sheet([r.image_ref for r in valid])
        critique = critic.rank_and_select(iter_ctx, valid, grid)

        winner = find_variant(valid, critique.winner.variant_id)

        # 次反復へ引き継ぎ
        baseline = winner
        critic_feedback = critique.winner

        persist_iteration(i, iter_ctx, valid, critique)

    return baseline

⸻

プロンプト設計の要点（曖昧さを残さない）

この種のループは「自由度が高いほど失敗」します。なので、各役割のプロンプトは“創造性”より先に“出力の構造”を固定します。

アイデアマンには「作品の意図」と「実装に落とす制約」を必須にします。特に、後工程が困るのは「抽象的なムード」だけが返ってくることなので、「どういう変数をどう振ると絵が変わるか（variation axes）」を必須フィールドにします。

アーティストには「何を変えたか」を必須にし、勝ち残りコードがある場合は差分方針を明確化させます。さらに、Grafix の API が不確実な前提なので、アーティストに「Grafix のレンダリング手順は、プロジェクト側のテンプレ（アダプタ）に合わせる。分からない点はテンプレを参照し、必要なら実行して確認してから書く」という規約を入れます。ここで「分からないのに想像で書く」を禁止します。

批評家には、ランキング理由が冗長になりすぎないように、各候補の理由は短く、勝者の理由と次アクションは厚く、という出力制御を入れます。次アクションは「優先度付き」で返し、次反復のアーティストが実装可能な粒度（変更対象、期待する効果、避けたい副作用）にします。

⸻

成果物と再現性（後で検証できる形で残す）

美的探索は「後で戻って比較」できないと価値が落ちます。各反復で最低限残すべきは、勝者だけでなく、全候補の再現情報です。

具体的には、各バリアントの (1) コード、(2) seed、(3) 主要パラメータ、(4) 出力画像、(5) 実行ログ（stdout/stderr）、(6) アーティスト要約、(7) 批評家のランキング結果、を同一ディレクトリに保存します。これで「なぜ勝ったか」「なぜ負けたか」「どの変更が効いたか」を後から追えます。

⸻

収束・停滞の扱い（N 回は回すが、無駄を減らす）

要件上 N 回ループは固定としても、途中で“停滞”が起きるのは普通です。停滞検出は機械的にできます。例えば、批評家スコア（相対評価でもよい）が 3 反復連続で改善しない、批評家が同じ指摘を繰り返す、勝者が毎回同じアーティストから出る、などです。

停滞時の介入として、オーケストレーターが次反復の M の割り当てを変えます。改善枠を減らして探索枠を増やす、アイデアマンを再呼び出しして「同じ意図のまま別アルゴリズムで」ブリーフを組み直す、などです。これは“最終的に 1 枚だけ選ぶ”設計と相性がよく、探索の失敗が成果を汚しません。

⸻

実装フェーズの進め方（Grafix 不確実性を潰す順序）

最後に、実装計画としての手順を文章で固定します。

まず最初にやるべきは、Grafix アダプタの最小実装です。ここでは「既知のテンプレスケッチ（最小の draw 相当、もしくは最小レンダリング）」を 1 回だけ動かして、画像が確実に書き出せるところまでを作ります。Grafix の API/CLI/依存が不明なので、ここは必ず実機確認して確定します。次に、アーティストが返す Artifact の保存規約（ディレクトリ、ファイル名、ログ）を確定します。これが決まると並列実行が安定します。

その後で、アイデアマン→アーティスト（単体）→批評家（単体）の直列パイプラインを 1 反復だけ動かし、JSON の整合と「勝者を次へ渡す」状態遷移が成立することを確認します。最後に M 並列化を入れ、失敗混入（2 件失敗、残り成功）のケースでも反復が進むことを確認します。ここまで来れば、N 反復は単なる繰り返しで、設計上の難所は潰れています。

⸻

この計画は「Grafix がどういう I/F を提供していても」アダプタで吸収できる前提で組んであります。逆に言うと、Grafix の詳細が固まった後にやるべきことは、アダプタ層の具体化と、アーティスト側のテンプレ（最小スケッチ雛形、実行コマンド、出力先規約）の固定だけです。ここさえ締めれば、残りはオーケストレーションとプロンプト整形の問題になります。
